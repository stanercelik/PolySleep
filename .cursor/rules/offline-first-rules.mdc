---
description: 
globs: 
alwaysApply: false
---
# Offline-First Mimarisi KÄ±lavuzu (SwiftData + Supabase)

# ğŸ¯ AmaÃ§ (Purpose)
Bu kÄ±lavuz, Cursor AI'ye bu projede kod Ã¼retirken veya yeniden dÃ¼zenlerken **her zaman offline-first akÄ±ÅŸÄ±nÄ± tercih etmesi** konusunda rehberlik eder. **SwiftData** aracÄ±lÄ±ÄŸÄ±yla yerel kalÄ±cÄ±lÄ±k **tek doÄŸru kaynaktÄ±r (single source of truth)**; Supabase ise fÄ±rsat buldukÃ§a senkronize olan uzak bir kopya olarak ele alÄ±nÄ±r.

## â˜‘ï¸ Temel Prensipler (Core Principles)

1.  **Yerel Ã–ncelikli Okuma/Yazma:** TÃ¼m veri okuma ve yazma iÅŸlemleri **yalnÄ±zca** `Repository` katmanÄ± Ã¼zerinden yapÄ±lmalÄ±dÄ±r. `View` veya `ViewModel` katmanlarÄ±nda doÄŸrudan Supabase API'leri Ã§aÄŸrÄ±lmamalÄ±dÄ±r.
2.  **Ã–nce Yerel, Sonra SÄ±raya Alma:** Yeni veri ekleme veya gÃ¼ncelleme iÅŸlemleri Ã¶nce yerel `ModelContext` kullanÄ±larak SwiftData'ya kaydedilmeli, ardÄ±ndan bu deÄŸiÅŸiklik arka planda senkronizasyon iÃ§in bir "Bekleyen DeÄŸiÅŸiklik" (Pending Change) kuyruÄŸuna eklenmelidir.
3.  **Tek DoÄŸru Kaynak SwiftData:** Uygulama arayÃ¼zÃ¼ (UI) her zaman doÄŸrudan SwiftData'dan beslenmelidir. Veriler Supabase'den Ã§ekilse bile Ã¶nce SwiftData'ya yazÄ±lmalÄ±, UI bu yerel veriyi gÃ¶zlemlemelidir.
4.  **YumuÅŸak Silme (Soft Delete):** Verileri kalÄ±cÄ± olarak silmek yerine, `@Model` iÃ§inde `isDeleted: Bool` veya `deletedAt: Date?` gibi bir alan kullanarak iÅŸaretleyin. GerÃ§ek silme iÅŸlemi (purge) sunucu tarafÄ±nda bir zamanlanmÄ±ÅŸ gÃ¶rev (cron job) ile periyodik olarak yapÄ±labilir.
5.  **Ã‡akÄ±ÅŸma Ã‡Ã¶zÃ¼mÃ¼ (Conflict Resolution):** Senkronizasyon sÄ±rasÄ±nda oluÅŸabilecek Ã§akÄ±ÅŸmalarÄ± Ã§Ã¶zmek iÃ§in **Son YazÄ±lan KazanÄ±r (Last-Write-Wins - LWW)** stratejisi kullanÄ±lmalÄ±dÄ±r. Bu strateji, her `@Model`'da bulunan `updatedAt: Date` alanÄ± kullanÄ±larak uygulanÄ±r. Senkronizasyon sÄ±rasÄ±nda, gelen verinin `updatedAt` deÄŸeri yereldeki verinin `updatedAt` deÄŸerinden daha eskiyse veya eÅŸitse, gelen veri gÃ¶z ardÄ± edilir.
6.  **AÄŸ Durumu YÃ¶netimi:** CihazÄ±n aÄŸ baÄŸlantÄ± durumunu (`NWPathMonitor` vb.) aktif olarak izleyin. BaÄŸlantÄ± kurulduÄŸunda bekleyen deÄŸiÅŸiklikler kuyruÄŸunu otomatik olarak iÅŸlemeye baÅŸlayÄ±n. ZayÄ±f veya kesintili baÄŸlantÄ± durumlarÄ±nÄ± yÃ¶netmek iÃ§in stratejiler geliÅŸtirin (Ã¶rn. zaman aÅŸÄ±mlarÄ±, tekrar deneme mekanizmalarÄ±).
7.  **Arka Plan Senkronizasyonu:** Bekleyen deÄŸiÅŸiklikler kuyruÄŸunu iÅŸlemek iÃ§in `BackgroundTasks` (Ã¶zellikle `BGAppRefreshTask`) kullanarak dÃ¼zenli aralÄ±klarla (Ã¶rn. ~15 dakikada bir) veya aÄŸ baÄŸlantÄ±sÄ± tekrar saÄŸlandÄ±ÄŸÄ±nda otomatik senkronizasyon tetikleyin.
8.  **GerÃ§ek ZamanlÄ± GÃ¼ncellemeler (Opsiyonel):** Supabase Realtime abonelikleri (`supabase.realtime.channel("public:*")`) kullanarak diÄŸer cihazlardan gelen deÄŸiÅŸiklikleri anlÄ±k olarak alÄ±n ve SwiftData'ya iÅŸleyin. Bu iÅŸlem, LWW prensibine uygun olarak (`updatedAt` kontrolÃ¼ yapÄ±larak) gerÃ§ekleÅŸtirilmelidir.

## ğŸ› ï¸ Uygulama Kontrol Listesi (Implementation Checklist)

1.  **Model TasarÄ±mÄ±:**
    *   Her SwiftData `@Model`'Ä± ÅŸu alanlarÄ± iÃ§ermelidir: `id: UUID`, `updatedAt: Date`.
    *   YumuÅŸak silme iÃ§in opsiyonel olarak `isDeleted: Bool = false` veya `deletedAt: Date?` ekleyin.
    *   SwiftData model ÅŸemalarÄ±nÄ± Supabase tablo ÅŸemalarÄ±yla olabildiÄŸince tutarlÄ± tutun (1-1 eÅŸleÅŸme idealdir).
2.  **Yerel Yazma Ä°ÅŸlemleri:**
    *   `Repository` katmanÄ±nda, `ModelContext.save()` iÅŸlemini sarmalayan ve baÅŸarÄ±lÄ± kayÄ±ttan sonra otomatik olarak bir `PendingChange` nesnesi oluÅŸturan `saveLocal<T: PersistentModel>(_ model: T) throws` gibi yardÄ±mcÄ± bir fonksiyon saÄŸlayÄ±n.
    *   `PendingChange` nesnesi, yapÄ±lan deÄŸiÅŸikliÄŸin tÃ¼rÃ¼nÃ¼ (create, update, delete), ilgili modelin `id`'sini ve deÄŸiÅŸikliÄŸin yapÄ±ldÄ±ÄŸÄ± veriyi (Ã¶rn. JSON formatÄ±nda) iÃ§ermelidir.
3.  **Bekleyen DeÄŸiÅŸiklikler KuyruÄŸu:**
    *   `PendingChange` nesnelerini ayrÄ± bir SwiftData modelinde veya basit bir dosyada (Ã¶rn. `PendingChanges.sqlite`, JSON dosyasÄ±) saklayÄ±n.
    *   KuyruÄŸun atomik olmasÄ±nÄ± saÄŸlayÄ±n (bir deÄŸiÅŸiklik iÅŸlenirken hata olursa kuyruktan silinmemeli, tekrar denenebilmeli).
4.  **Senkronizasyon Motoru (`SyncEngine`):**
    *   `SyncEngine` adÄ±nda merkezi bir servis oluÅŸturun.
    *   `performSync()`: Hem bekleyen deÄŸiÅŸiklikleri Supabase'e gÃ¶nderme (push) hem de Supabase'den gÃ¼ncel verileri Ã§ekme (pull) iÅŸlemlerini yÃ¶netir.
        *   **Push:** Kuyruktaki deÄŸiÅŸiklikleri Supabase'e gÃ¶nderir. BaÅŸarÄ±lÄ± olanlarÄ± kuyruktan siler. Hata yÃ¶netimi ve tekrar deneme mekanizmasÄ± iÃ§erir.
        *   **Pull:** Supabase'den en son senkronizasyondan sonraki deÄŸiÅŸiklikleri Ã§eker ve LWW prensibine gÃ¶re SwiftData'ya iÅŸler. `lastPulledAt` zaman damgasÄ±nÄ± yÃ¶netir.
    *   `NWPathMonitor` ve `BGAppRefreshTask` ile entegre Ã§alÄ±ÅŸÄ±r.
    *   `flushQueue()`: Manuel senkronizasyon tetikleme (isteÄŸe baÄŸlÄ±).
5.  **Supabase RPC FonksiyonlarÄ±:**
    *   Senkronizasyon mantÄ±ÄŸÄ±nÄ± (Ã¶zellikle pull) verimli hale getirmek iÃ§in Supabase tarafÄ±nda `push_changes(changes jsonb)` ve `pull_changes(last_pulled_at timestamp with time zone)` gibi RPC (Remote Procedure Call) fonksiyonlarÄ± oluÅŸturun. Bu fonksiyonlar, istemci tarafÄ±nda karmaÅŸÄ±k sorgular yapmaktansa, sunucu tarafÄ±nda veriyi iÅŸleyip hazÄ±r hale getirir.
6.  **KullanÄ±cÄ± Deneyimi (UX):**
    *   **Ä°yimser ArayÃ¼z (Optimistic UI):** DeÄŸiÅŸiklikler yerel olarak kaydedildiÄŸi anda UI gÃ¼ncellenmelidir. Senkronizasyonun tamamlanmasÄ± beklenmemelidir.
    *   **Senkronizasyon Durumu GÃ¶stergesi:** KullanÄ±cÄ±ya uygulamanÄ±n en son ne zaman senkronize edildiÄŸini, bekleyen deÄŸiÅŸiklik olup olmadÄ±ÄŸÄ±nÄ± veya bir senkronizasyon hatasÄ± olup olmadÄ±ÄŸÄ±nÄ± gÃ¶steren gÃ¶rsel bir bildirim saÄŸlayÄ±n.
    *   **Hata Bildirimi:** Senkronizasyon hatalarÄ±nÄ± (Ã¶zellikle Ã§Ã¶zÃ¼mlenemeyen Ã§akÄ±ÅŸmalar veya kalÄ±cÄ± sunucu hatalarÄ±) kullanÄ±cÄ±ya anlaÅŸÄ±lÄ±r bir dille bildirin.

## ğŸ”– Dosya KalÄ±plarÄ± & Ã–rnekler (File Patterns & Examples)
*   `Models/UserSchedule.swift`: DoÄŸru bir offline-first `@Model` Ã¶rneÄŸi.
*   `Services/SyncEngine.swift`: Senkronizasyon iskeletini saÄŸlar. Yeni modeller eklerken bu yapÄ±yÄ± referans alÄ±n.
*   `Services/Repository.swift`: Veri eriÅŸim katmanÄ±. TÃ¼m yerel ve uzak iÅŸlemler buradan yÃ¶netilir.
*   `Data/PendingChange.swift`: Bekleyen deÄŸiÅŸiklikleri temsil eden `@Model`.

## ğŸš« KaÃ§Ä±nÄ±lmasÄ± Gerekenler (Anti-Patterns - Reddet & DÃ¼zelt)
*   âŒ `ViewModel` veya `View` iÃ§inde doÄŸrudan Supabase istemcisini (`supabase.client`) kullanarak `.insert()`, `.update()`, `.delete()` veya `.select()` yapmak.
*   âŒ Supabase'den veri Ã§ekerken (`.select()`) bunu Ã¶nce SwiftData'ya kaydetmeden doÄŸrudan `View` iÃ§inde kullanmak.
*   âŒ SÃ¼rekli internet baÄŸlantÄ±sÄ± olduÄŸunu varsaymak. TÃ¼m Supabase Ã§aÄŸrÄ±larÄ±nÄ± aÄŸ durumu kontrolleri (`isOnline` vb.) ile sarmalayÄ±n veya `SyncEngine` Ã¼zerinden yapÄ±n.
*   âŒ `updatedAt` alanÄ± olmadan LWW Ã§akÄ±ÅŸma Ã§Ã¶zÃ¼mÃ¼nÃ¼ uygulamaya Ã§alÄ±ÅŸmak.
*   âŒ Bekleyen deÄŸiÅŸiklikler kuyruÄŸunu yÃ¶netmeden doÄŸrudan Supabase'e yazmaya Ã§alÄ±ÅŸmak.

## ğŸ’¡ Cursor AI Ä°puÃ§larÄ± (Tips for Cursor AI)
*   "X Ã¶zelliÄŸini ekle" istendiÄŸinde, Supabase API Ã§aÄŸrÄ±larÄ±ndan **Ã¶nce** **SwiftData** modelini ve `Repository` fonksiyonlarÄ±nÄ± oluÅŸtur.
*   Senkronizasyon durumu (`syncState`) iÃ§in `@Published` bir Ã¶zellik kullanarak hem baÅŸarÄ±lÄ± ekleme/gÃ¼ncelleme hem de hata/geri alma (rollback) durumlarÄ±nÄ± gÃ¶sterecek Ã¶rnekler sun.
*   DeÄŸiÅŸiklik akÄ±ÅŸlarÄ± (change streams) iÃ§in Combine `Publisher` veya Swift Concurrency `AsyncSequence` kullanÄ±mÄ±nÄ± tercih et. `Repository`'den dÃ¶nen veriler bunlar olmalÄ±.
*   YumuÅŸak silme (`isDeleted = true`) ve `updatedAt` alanlarÄ±nÄ± gÃ¼ncellemeyi unutma.

---

> Bu kuralÄ± kÄ±sa (< 300 satÄ±r) tutun ve **sadece** offline-first davranÄ±ÅŸÄ±na odaklanÄ±n. DiÄŸer tÃ¼m mimari yÃ¶nlendirmeler `ARCHITECTURE.md` dosyasÄ±nda bulunur ve kasÄ±tlÄ± olarak bu kuraldan Ã§Ä±karÄ±lmÄ±ÅŸtÄ±r.

