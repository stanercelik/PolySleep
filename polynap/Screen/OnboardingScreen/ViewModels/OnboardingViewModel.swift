import SwiftUI
import SwiftData

// Enum dÃ¶nÃ¼ÅŸÃ¼m hatasÄ± iÃ§in Ã¶zel hata tipi
struct EnumConversionError: Error, LocalizedError {
    let enumType: String
    let value: String
    
    var errorDescription: String? {
        return "'\(value)' deÄŸeri '\(enumType)' enum tipine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lemedi."
    }
}

@MainActor
final class OnboardingViewModel: ObservableObject {
    // MARK: - Dependencies
    private let recommender: SleepScheduleRecommender
    private let analyticsManager = AnalyticsManager.shared
    private var modelContext: ModelContext?
    
    // ğŸ“Š Analytics: Onboarding timing tracking
    private var onboardingStartTime: Date?
    
    // MARK: - Published Properties
    @Published var currentPage = 0
    let totalPages = 12
    @Published var shouldNavigateToSleepSchedule = false
    @Published var showStartButton = false
    @Published var isLoadingRecommendation = false
    @Published var showError = false
    @Published var errorMessage = ""
    
    // YÃ¼kleme ekranÄ± iÃ§in yeni deÄŸiÅŸkenler
    @Published var recommendationProgress: Double = 0.0
    @Published var recommendationStatusMessage: String = ""
    @Published var recommendationComplete: Bool = false
    @Published var showLoadingView: Bool = false
    @Published var navigateToMainScreen: Bool = false
    
    // Ana ekrana geÃ§iÅŸ iÃ§in NavigationLink deÄŸiÅŸkeni
    @Published var goToMainScreen: Bool = false
    
    // User selections
    @Published var previousSleepExperience: PreviousSleepExperience?
    @Published var ageRange: AgeRange?
    @Published var workSchedule: WorkSchedule?
    @Published var napEnvironment: NapEnvironment?
    @Published var lifestyle: Lifestyle?
    @Published var knowledgeLevel: KnowledgeLevel?
    @Published var healthStatus: HealthStatus?
    @Published var motivationLevel: MotivationLevel?
    @Published var sleepGoal: SleepGoal?
    @Published var socialObligations: SocialObligations?
    @Published var disruptionTolerance: DisruptionTolerance?
    @Published var chronotype: Chronotype?
    
    // MARK: - Initialization
    init(modelContext: ModelContext? = nil) {
        self.recommender = SleepScheduleRecommender(repository: Repository.shared)
        self.modelContext = modelContext
        if modelContext == nil {
            print("âš ï¸ OnboardingViewModel: ModelContext nil olarak baÅŸlatÄ±ldÄ±. View'dan inject edildiÄŸinden emin olun.")
        } else {
            print("âœ… OnboardingViewModel: ModelContext baÅŸarÄ±yla baÅŸlatÄ±ldÄ±/inject edildi.")
        }
    }
    
    func setModelContext(_ context: ModelContext) {
        if self.modelContext == nil { // Sadece nil ise ata, birden fazla kez atanmasÄ±nÄ± engelle
            self.modelContext = context
            
            // ğŸ“Š Analytics: Onboarding baÅŸlangÄ±Ã§ zamanÄ±nÄ± kaydet
            if onboardingStartTime == nil {
                onboardingStartTime = Date()
            }
            
            print("âœ… OnboardingViewModel: setModelContext Ã§aÄŸrÄ±ldÄ±.")
        }
    }
    
    // MARK: - Computed Properties
    var canMoveNext: Bool {
        switch currentPage {
        case 0: return previousSleepExperience != nil
        case 1: return ageRange != nil
        case 2: return workSchedule != nil
        case 3: return napEnvironment != nil
        case 4: return lifestyle != nil
        case 5: return knowledgeLevel != nil
        case 6: return healthStatus != nil
        case 7: return motivationLevel != nil
        case 8: return sleepGoal != nil
        case 9: return socialObligations != nil
        case 10: return disruptionTolerance != nil
        case 11: return chronotype != nil
        default: return false
        }
    }
    
    // MARK: - Methods
    func moveNext() {
        guard !isLoadingRecommendation else { return }
        
        if currentPage < totalPages - 1 {
            withAnimation(.easeInOut(duration: 0.25)) {
                currentPage += 1
            }
        } else {
            // Son sayfada ise, loading'i gÃ¶ster ve recommendation'Ä± baÅŸlat
            isLoadingRecommendation = true
            Task {
                await startRecommendationProcess()
            }
        }
    }
    
    func movePrevious() {
        guard !isLoadingRecommendation else { return }
        
        if currentPage > 0 {
            withAnimation(.easeInOut(duration: 0.25)) {
                currentPage -= 1
            }
        }
    }
    
    func skipOnboarding() async {
        print("â­ï¸ OnboardingViewModel: Onboarding atlandÄ±")
        
        // Skip analytics event
        analyticsManager.logOnboardingSkipped()
        
        // Mark onboarding as skipped in UserPreferences
        await markOnboardingAsSkippedInSwiftData()
        
        // Set up default biphasic sleep schedule
        await setupDefaultBiphasicSchedule()
        
        // ContentView will automatically navigate to MainTabBarView since hasCompletedOnboarding = true
        print("âœ… OnboardingViewModel: Skip tamamlandÄ±, ContentView otomatik olarak MainTabBarView'a geÃ§ecek")
    }
    
    private func markOnboardingAsSkippedInSwiftData() async {
        guard let modelContext = self.modelContext else {
            print("âŒ OnboardingViewModel: Onboarding atlandÄ± olarak iÅŸaretlenemedi, ModelContext yok.")
            return
        }
        
        let fetchDescriptor = FetchDescriptor<UserPreferences>()
        do {
            if let userPreferences = try modelContext.fetch(fetchDescriptor).first {
                userPreferences.hasSkippedOnboarding = true
                userPreferences.hasCompletedOnboarding = true // Skip edilse de onboarding tamamlandÄ± sayÄ±lÄ±r
                userPreferences.hasCompletedQuestions = false // Sorular tamamlanmadÄ±
                try modelContext.save()
                print("âœ… OnboardingViewModel: UserPreferences'da onboarding atlandÄ± olarak iÅŸaretlendi.")
            } else {
                let newPreferences = UserPreferences(
                    hasCompletedOnboarding: true, // Skip edilse de onboarding tamamlandÄ± sayÄ±lÄ±r
                    hasCompletedQuestions: false,
                    hasSkippedOnboarding: true
                )
                modelContext.insert(newPreferences)
                try modelContext.save()
                print("âœ… OnboardingViewModel: UserPreferences oluÅŸturuldu ve onboarding atlandÄ± olarak iÅŸaretlendi.")
            }
        } catch {
            print("âŒ OnboardingViewModel: UserPreferences gÃ¼ncellenirken hata: \(error.localizedDescription)")
        }
    }
    
    private func setupDefaultBiphasicSchedule() async {
        print("ğŸ”§ OnboardingViewModel: VarsayÄ±lan biphasic schedule ayarlanÄ±yor...")
        
        // Create a biphasic schedule based on the JSON data
        let biphasicSchedule = UserScheduleModel(
            id: "biphasic",
            name: "Biphasic Sleep",
            description: LocalizedDescription(
                en: "A sleep pattern with one core sleep period and one short nap during the day, often practiced in some cultures as an afternoon siesta.",
                tr: "Bir ana uyku dÃ¶nemi ve gÃ¼n iÃ§inde kÄ±sa bir ÅŸekerlemeden oluÅŸan uyku dÃ¼zeni. Ã–zellikle bazÄ± kÃ¼ltÃ¼rlerde Ã¶ÄŸleden sonra yapÄ±lan siesta ÅŸeklinde uygulanabilir.",
                ja: "å¤œã«ã¾ã¨ã‚ã¦å¯ã‚‹æ™‚é–“ã®ã»ã‹ã«ã€æ—¥ä¸­ã«çŸ­ã„ãŠæ˜¼å¯ã‚’1å›ã¨ã‚‹ç¡çœ ã‚¹ã‚¿ã‚¤ãƒ«ã€‚ã‚¹ãƒšã‚¤ãƒ³ã®ã‚·ã‚¨ã‚¹ã‚¿ã¿ãŸã„ã«ã€æ–‡åŒ–ã¨ã—ã¦æ ¹ä»˜ã„ã¦ã„ã‚‹åœ°åŸŸã‚‚ã‚ã‚Šã¾ã™ã‚ˆã€‚",
                de: "Ein Schlafmuster mit einer Kernschlafphase und einem kurzen Nickerchen wÃ¤hrend des Tages, das in einigen Kulturen oft als Nachmittagssiesta praktiziert wird.",
                ms: "Corak tidur dengan satu tempoh tidur teras dan satu tidur sebentar pendek pada siang hari, sering diamalkan dalam sesetengah budaya sebagai siesta petang.",
                th: "à¸£à¸¹à¸›à¹à¸šà¸šà¸à¸²à¸£à¸™à¸­à¸™à¸—à¸µà¹ˆà¸¡à¸µà¸Šà¹ˆà¸§à¸‡à¸à¸²à¸£à¸™à¸­à¸™à¸«à¸¥à¸±à¸à¸«à¸™à¸¶à¹ˆà¸‡à¸„à¸£à¸±à¹‰à¸‡à¹à¸¥à¸°à¸à¸²à¸£à¸«à¸¥à¸±à¸šà¸ªà¸±à¹‰à¸™à¹† à¹ƒà¸™à¸Šà¹ˆà¸§à¸‡à¸à¸¥à¸²à¸‡à¸§à¸±à¸™ à¸¡à¸±à¸à¸à¸šà¹ƒà¸™à¸šà¸²à¸‡à¸§à¸±à¸’à¸™à¸˜à¸£à¸£à¸¡à¹€à¸›à¹‡à¸™à¸à¸²à¸£à¸™à¸­à¸™à¸šà¹ˆà¸²à¸¢"
            ),
            totalSleepHours: 6.5,
            schedule: [
                SleepBlock(
                    startTime: "23:00",
                    duration: 360, // 6 hours core sleep
                    type: "core",
                    isCore: true
                ),
                SleepBlock(
                    startTime: "14:00",
                    duration: 30, // 30 minutes nap
                    type: "nap",
                    isCore: false
                )
            ],
            isPremium: false
        )
        
        do {
            // Save the schedule using the Repository
            _ = try await Repository.shared.saveSchedule(biphasicSchedule)
            print("âœ… OnboardingViewModel: VarsayÄ±lan biphasic schedule kaydedildi ve aktif edildi.")
            
            // Update ScheduleManager with the new active schedule
            await ScheduleManager.shared.loadActiveScheduleFromRepository()
            print("âœ… OnboardingViewModel: ScheduleManager gÃ¼ncellendi.")
            
        } catch {
            print("âŒ OnboardingViewModel: VarsayÄ±lan biphasic schedule kaydedilirken hata: \(error.localizedDescription)")
            
            // Fallback to current default schedule if biphasic setup fails
            let fallbackSchedule = UserScheduleModel.defaultSchedule
            do {
                _ = try await Repository.shared.saveSchedule(fallbackSchedule)
                await ScheduleManager.shared.loadActiveScheduleFromRepository()
                print("âš ï¸ OnboardingViewModel: Fallback schedule kullanÄ±ldÄ±.")
            } catch {
                print("âŒ OnboardingViewModel: Fallback schedule bile kaydedilemedi: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - Recommendation Process
    func startRecommendationProcess() async {
        // KullanÄ±cÄ± seÃ§imlerinin tam olup olmadÄ±ÄŸÄ±nÄ± kontrol et
        guard previousSleepExperience != nil,
              ageRange != nil,
              workSchedule != nil,
              napEnvironment != nil,
              lifestyle != nil,
              knowledgeLevel != nil,
              healthStatus != nil,
              motivationLevel != nil,
              sleepGoal != nil,
              socialObligations != nil,
              disruptionTolerance != nil,
              chronotype != nil else {
            await MainActor.run {
                errorMessage = L("onboarding.error.incompleteAnswers", table: "Onboarding")
                showError = true
                showLoadingView = false
            }
            return
        }
        
        await MainActor.run {
            showLoadingView = true
            recommendationProgress = 0.0
            recommendationStatusMessage = L("onboarding.loading.preparingProgram", table: "Onboarding")
            recommendationComplete = false
        }
        
        // Bilgileri kaydet
        await saveUserPreferences()
    }
    
    // MARK: - UserPreferences kaydÄ±
    func markOnboardingAsCompletedInSwiftData() async {
        guard let modelContext = self.modelContext else {
            print("âŒ OnboardingViewModel: Onboarding tamamlandÄ± olarak iÅŸaretlenemedi, ModelContext yok.")
            return
        }
        let fetchDescriptor = FetchDescriptor<UserPreferences>()
        do {
            if let userPreferences = try modelContext.fetch(fetchDescriptor).first {
                userPreferences.hasCompletedOnboarding = true
                try modelContext.save()
                print("âœ… OnboardingViewModel: UserPreferences'da onboarding tamamlandÄ± olarak iÅŸaretlendi.")
            } else {
                // WelcomeView'da oluÅŸturulmuÅŸ olmalÄ±. EÄŸer yoksa burada oluÅŸturmak bir yedek plan.
                let newPreferences = UserPreferences(hasCompletedOnboarding: true)
                modelContext.insert(newPreferences)
                try modelContext.save()
                print("âœ… OnboardingViewModel: UserPreferences oluÅŸturuldu ve onboarding tamamlandÄ± olarak iÅŸaretlendi.")
            }
        } catch {
            print("âŒ OnboardingViewModel: UserPreferences gÃ¼ncellenirken hata: \(error.localizedDescription)")
        }
    }
    
    // MARK: - Saving
    func saveUserPreferences() async {
        print("\n=== Saving User Preferences ===")
        
        guard let sleepExperience = previousSleepExperience,
              let ageRange = ageRange,
              let workSchedule = workSchedule,
              let napEnvironment = napEnvironment,
              let lifestyle = lifestyle,
              let knowledgeLevel = knowledgeLevel,
              let healthStatus = healthStatus,
              let motivationLevel = motivationLevel,
              let sleepGoal = sleepGoal,
              let socialObligations = socialObligations,
              let disruptionTolerance = disruptionTolerance,
              let chronotype = chronotype
        else {
            print("âŒ Error: Some user preferences are not set")
            await showErrorMessage(L("onboarding.error.incompleteAnswers", table: "Onboarding"))
            return
        }
        
        updateProgress(0.15, L("onboarding.loading.savingPreferences", table: "Onboarding"))
        
        print("\nSaving values:")
        print("- Sleep Experience: \(sleepExperience.rawValue)")
        print("- Age Range: \(ageRange.rawValue)")
        print("- Work Schedule: \(workSchedule.rawValue)")
        print("- Nap Environment: \(napEnvironment.rawValue)")
        print("- Lifestyle: \(lifestyle.rawValue)")
        print("- Knowledge Level: \(knowledgeLevel.rawValue)")
        print("- Health Status: \(healthStatus.rawValue)")
        print("- Motivation Level: \(motivationLevel.rawValue)")
        print("- Sleep Goal: \(sleepGoal.rawValue)")
        print("- Social Obligations: \(socialObligations.rawValue)")
        print("- Disruption Tolerance: \(disruptionTolerance.rawValue)")
        print("- Chronotype: \(chronotype.rawValue)")
        
        let answersTuples: [(String, String)] = [
            ("onboarding.sleepExperience", sleepExperience.rawValue),
            ("onboarding.ageRange", ageRange.rawValue),
            ("onboarding.workSchedule", workSchedule.rawValue),
            ("onboarding.napEnvironment", napEnvironment.rawValue),
            ("onboarding.lifestyle", lifestyle.rawValue),
            ("onboarding.knowledgeLevel", knowledgeLevel.rawValue),
            ("onboarding.healthStatus", healthStatus.rawValue),
            ("onboarding.motivationLevel", motivationLevel.rawValue),
            ("onboarding.sleepGoal", sleepGoal.rawValue),
            ("onboarding.socialObligations", socialObligations.rawValue),
            ("onboarding.disruptionTolerance", disruptionTolerance.rawValue),
            ("onboarding.chronotype", chronotype.rawValue)
        ]
        
        updateProgress(0.30, L("onboarding.loading.savingDataLocally", table: "Onboarding"))
        
        do {
            guard let modelContext = self.modelContext else {
                print("âŒ ModelContext bulunamadÄ±, onboarding yanÄ±tlarÄ± kaydedilemedi")
                await showErrorMessage(L("onboarding.error.noModelContext", table: "Onboarding"))
                return
            }
            
            var currentUserModel: User? = nil
            if let localUserIdString = AuthManager.shared.currentUser?.id,
               let localUserUUID = UUID(uuidString: localUserIdString) {
                
                let predicate = #Predicate<User> { user in user.id == localUserUUID }
                let descriptor = FetchDescriptor<User>(predicate: predicate)
                do {
                    currentUserModel = try modelContext.fetch(descriptor).first
                    if currentUserModel == nil {
                        print("âš ï¸ OnboardingViewModel: ID'si \(localUserUUID) olan User @Model bulunamadÄ±. OnboardingAnswer kullanÄ±cÄ±sÄ±z kaydedilecek.")
                        // Tamamen offline bir uygulamada, User @Model'i, yerel kullanÄ±cÄ± ilk oluÅŸturulduÄŸunda
                        // veya burada AuthManager.shared.currentUser bilgilerine dayanarak oluÅŸturabilirsiniz.
                    }
                } catch {
                    print("âŒ OnboardingViewModel: User @Model alÄ±nÄ±rken hata: \(error.localizedDescription)")
                }
            } else {
                print("â„¹ï¸ OnboardingViewModel: AuthManager'dan geÃ§erli kullanÄ±cÄ± ID'si alÄ±namadÄ±.")
            }
            
            try cleanupExistingAnswers(in: modelContext)
            
            for (questionKey, answerValue) in answersTuples {
                let newAnswerData = OnboardingAnswerData(
                    user: currentUserModel,
                    question: questionKey,
                    answer: answerValue,
                    date: Date(),
                    createdAt: Date(),
                    updatedAt: Date()
                )
                modelContext.insert(newAnswerData)
            }
            
            try modelContext.save()
            print("âœ… Onboarding yanÄ±tlarÄ± yerel olarak SwiftData'ya kaydedildi.")
            
            updateProgress(0.45, L("onboarding.loading.calculatingSchedule", table: "Onboarding"))
            await getRecommendedSchedule()
            
        } catch {
            print("âŒ Onboarding yanÄ±tlarÄ± SwiftData'ya kaydedilirken hata: \(error.localizedDescription)")
            await showErrorMessage(String(format: L("onboarding.error.preferencesSaveFailed", table: "Onboarding"), error.localizedDescription))
        }
    }
    
    // Mevcut yanÄ±tlarÄ± temizleme yardÄ±mcÄ± fonksiyonu
    private func cleanupExistingAnswers(in context: ModelContext) throws {
        let descriptor = FetchDescriptor<OnboardingAnswerData>()
        let existingAnswers = try context.fetch(descriptor)
        
        if !existingAnswers.isEmpty {
            print("ğŸ§¹ \(existingAnswers.count) mevcut yanÄ±t temizleniyor...")
            for answer in existingAnswers {
                context.delete(answer)
            }
        }
    }
    
    private func showErrorMessage(_ message: String) async {
        await MainActor.run {
            errorMessage = message
            showError = true
            showLoadingView = false
        }
    }
    
    private func updateProgress(_ targetProgress: Double, _ message: String) {
        // Animasyon iÃ§in baÅŸlangÄ±Ã§ deÄŸeri
        let startProgress = recommendationProgress
        let totalSteps = 20
        let animationDuration = 1.0 // Toplam animasyon sÃ¼resi (saniye)
        
        for step in 0...totalSteps {
            let delayForStep = animationDuration * Double(step) / Double(totalSteps)
            let progressForStep = startProgress + (targetProgress - startProgress) * Double(step) / Double(totalSteps)
            
            DispatchQueue.main.asyncAfter(deadline: .now() + delayForStep) {
                withAnimation(.easeInOut(duration: animationDuration / Double(totalSteps))) {
                    self.recommendationProgress = progressForStep
                    
                    // Sadece son adÄ±mda mesajÄ± gÃ¼ncelle
                    if step == totalSteps {
                        self.recommendationStatusMessage = message
                    }
                }
            }
        }
    }
    
    func getRecommendedSchedule() async {
        updateProgress(0.6, L("onboarding.loading.analyzingProgram", table: "Onboarding"))
        
        // Yapay bir gecikme ekleyelim ki kullanÄ±cÄ± hesaplamanÄ±n yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rsÃ¼n
        try? await Task.sleep(nanoseconds: 1_500_000_000) // 1.5 saniye
        
        updateProgress(0.75, L("onboarding.loading.almostReady", table: "Onboarding"))
        
        do {
            if let recommendation = try await recommender.recommendSchedule() {
                print("\n=== Recommended Schedule ===")
                print("Name: \(recommendation.schedule.name)")
                print("Confidence Score: \(recommendation.confidenceScore)")
                
                // Yapay bir gecikme ekleyelim ki kullanÄ±cÄ± hesaplamanÄ±n yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rsÃ¼n
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 saniye
                
                updateProgress(0.9, L("onboarding.loading.savingProgram", table: "Onboarding"))
                
                let recommendedUserScheduleModel = recommendation.schedule.toUserScheduleModel
                do {
                    // Repository.saveSchedule, ScheduleEntity'yi kaydeder ve aktif eder.
                    _ = try await Repository.shared.saveSchedule(recommendedUserScheduleModel)
                    print("âœ… Ã–nerilen program (ScheduleEntity) yerel olarak kaydedildi ve aktif edildi.")
                    
                    // ScheduleManager'Ä±n aktif programÄ±nÄ± gÃ¼ncellemesini saÄŸla
                    await ScheduleManager.shared.loadActiveScheduleFromRepository()
                    
                    await MainActor.run {
                        updateProgress(1.0, L("onboarding.loading.ready", table: "Onboarding"))
                        recommendationComplete = true
                    }
                } catch {
                    print("âŒ Ã–nerilen program kaydedilirken/aktifleÅŸtirilirken hata: \(error.localizedDescription)")
                    await handleErrorButContinue(L("onboarding.error.programSetupFailed", table: "Onboarding"))
                }
            } else {
                print("âŒ Failed to get recommendation")
                
                // Ã–neri bulunamazsa varsayÄ±lan bir programÄ± kaydet
                print("âš ï¸ Tavsiye bulunamadÄ±. VarsayÄ±lan program ayarlanÄ±yor.")
                let defaultScheduleModel = UserScheduleModel.defaultSchedule
                do {
                    _ = try await Repository.shared.saveSchedule(defaultScheduleModel)
                    print("âœ… VarsayÄ±lan program yerel olarak kaydedildi ve aktif edildi.")
                    await ScheduleManager.shared.loadActiveScheduleFromRepository()
                    await handleErrorButContinue(L("onboarding.error.noRecommendationFound", table: "Onboarding"))
                } catch {
                    print("âŒ VarsayÄ±lan program kaydedilirken/aktifleÅŸtirilirken hata: \(error.localizedDescription)")
                    await handleErrorButContinue(L("onboarding.error.defaultProgramSetupFailed", table: "Onboarding"))
                }
            }
        } catch let error as EnumConversionError {
            print("âŒ Enum conversion error: \(error.localizedDescription)")
            await handleErrorButContinue(L("onboarding.error.dataProcessingFailed", table: "Onboarding"))
        } catch {
            print("âŒ Error getting recommendation: \(error.localizedDescription)")
            await handleErrorButContinue(L("onboarding.error.unexpectedError", table: "Onboarding"))
        }
    }
    
    // Hata durumlarÄ±nda yÃ¼kleme ekranÄ±nÄ± tamamlamak iÃ§in yardÄ±mcÄ± fonksiyon
    private func handleErrorButContinue(_ message: String) async {
        await MainActor.run {
            updateProgress(0.9, message)
        }
        try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 saniye
        await MainActor.run {
            withAnimation {
                self.recommendationProgress = 1.0
                self.recommendationStatusMessage = L("onboarding.loading.ready", table: "Onboarding")
                self.recommendationComplete = true
            }
        }
    }
    
    func startUsingApp() {
        navigateToMainScreen = true
    }
    
    // ğŸ“Š Analytics: SeÃ§ilen schedule'Ä± analytics iÃ§in string olarak dÃ¶ndÃ¼r
    private func getSelectedScheduleForAnalytics() -> String {
        // Schedule Manager'dan aktif schedule'Ä± al
        if let activeSchedule = ScheduleManager.shared.activeSchedule {
            return activeSchedule.name
        }
        
        // EÄŸer schedule henÃ¼z aktif deÄŸilse, varsayÄ±lan schedule'Ä± dÃ¶ndÃ¼r
        return UserScheduleModel.defaultSchedule.name
    }
    
    // Ana ekrana geÃ§iÅŸ iÅŸlemini yÃ¶netir
    func handleNavigationToMainScreen() {
        print("ğŸ¯ OnboardingViewModel: handleNavigationToMainScreen() Ã‡AÄRILDI!")
        
        // ğŸ“Š Analytics: Onboarding tamamlanma event'Ä± (enhanced parameters ile)
        let timeTaken = onboardingStartTime != nil ? Date().timeIntervalSince(onboardingStartTime!) : 0
        let stepsCompleted = totalPages // TÃ¼m adÄ±mlarÄ± tamamladÄ±ÄŸÄ± iÃ§in totalPages
        let selectedSchedule = getSelectedScheduleForAnalytics()
        
        print("ğŸ¯ Analytics Debug:")
        print("   - timeTaken: \(timeTaken) seconds")
        print("   - stepsCompleted: \(stepsCompleted)")
        print("   - selectedSchedule: \(selectedSchedule)")
        print("   - onboardingStartTime: \(onboardingStartTime?.description ?? "nil")")
        
        print("ğŸ“Š Analytics: logOnboardingCompleted Ã‡AÄRILIYOR...")
        analyticsManager.logOnboardingCompleted(
            timeTaken: timeTaken,
            stepsCompleted: stepsCompleted,
            selectedSchedule: selectedSchedule
        )
        print("ğŸ“Š Analytics: logOnboardingCompleted Ã‡AÄRILDI âœ…")
        
        // Onboarding tamamlandÄ±, doÄŸrudan ana ekrana geÃ§iÅŸ yap
        withAnimation {
            goToMainScreen = true
        }
        
        // Ana ekrana geÃ§tikten 1 saniye sonra rating request
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.requestRatingIfNeeded()
        }
    }
    
    // Rating request'ini yÃ¶netir
    private func requestRatingIfNeeded() {
        print("ğŸ“ OnboardingViewModel: Rating request baÅŸlatÄ±lÄ±yor...")
        
        RatingManager.shared.requestRating {
            print("ğŸ“ OnboardingViewModel: Rating completed, paywall tetikleniyor...")
            
            // Rating tamamlandÄ±ktan 0.5 saniye sonra paywall tetikle
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.triggerOnboardingPaywall()
            }
        }
    }
    
    // Onboarding sonrasÄ± paywall'Ä± tetikler
    private func triggerOnboardingPaywall() {
        print("ğŸ“± OnboardingViewModel: Onboarding paywall tetikleniyor...")
        PaywallManager.shared.presentPaywall(trigger: .onboardingComplete)
    }
}
